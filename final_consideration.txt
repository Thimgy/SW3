On the project, there are 8 different responsibilities:
1. Reading the input content from the input file
2. Splitting the input content line by line
3. Splitting each line word by word
4. Generating all the circular shift
5. Merging the list of word into line
6. Sorting the lines
7. Merging the lines into the output content
8. Writing the output content in the output file

There are some implied processing layer with the responsibilities:
1 read file
 2 split on new line
  3 split on ' '
   4 gen shifts
  5 join with ' '
  6 sort
 7 join with new line
8 write file

1 & 8 depends on the File system 
2 & 7 depends on the os ("\n" on Unix and "\r\n" on Windows)
3 & 5 depends on the application specification (first candidate for update)

Currently:
Input handle: 1, 2, 3
Circular Shift: 4, 5
Alphabetical Sort: 6
Output: 7, 8

ackward splitting of resp 3 and 5 between 2 classes
--- Input ---
  3 split on ' '
--- CircularShift ---
   4 gen shifts
  5 join with ' '

I think 3 & 5 are the most likely to change and but word delimiter are used in 2 different classes:
issue changing the word delimiter might:
 1. require updating 2 classes (not great for information hiding)
 2. if multi word delimiter, no way to forward which word delimiter followed a particular one word
  (for instance: with split on ",," or " ":
		"An example,,or two"
			=> {"An", "example", "or", "two"}
			Information lost on the word delimiter
  )

Option 0: Not worth it
  likeliness of spec changing < "cost" to adapt the code
  so not worth it to change things
Option 1: information lost is fine
  split with word delimiter, always join with " "
  pro: no change required
  con: remove word splitter
Option 2: moving resp 3 with 4 and 5
  extract resp 3 from Input and add it to CircularShift
  pro: 1 class using the word delimiter => easier to adapt
  con: internal logic not specified but more complexe
Option 3: Intrusif change
  add the word delimiter after the word (default one for the last)
  extra char after the line won't matter while sorting the lines
  (e.g. "An example"
	    r3=> {"An ", "example "}
		r5=> {"An example ", "example An "}
  )
  pro: resp 3 and 5 are handled before giving the list of word
       doesn't change the UML
  con: may leave extra space after the last word
Option 4: Intrusif change and removal or left over
  Similar to opt 2 but remove the length of the word splitting char from each shift
  Require an aditionnal object to wrap CircularShift taking resp. 3 and 5
  (last word position is fixed: 0, 1, 2, 3, ..., n-1)
  Can keep word delimiter at the end of the line.
  (e.g. dropping " " but keeping ":" on end of line:
       "Ex:An example"
		r3=> {"Ex:", "An ", "example "} + delimiter length {0, 1, 1}
		r4=> {"An example Ex:", "example Ex:An ", "Ex:An example "}
		r5=> {"An example Ex:", "example Ex:An" , "Ex:An example" }
  )
  pro: No unwanted left over
       can leave a word delimiter by giving length of 0 (no char remove)
  con: larger memory footprint
       require the shifts in a specfic order
	   require 1 shift per input
Option 5:
  similar to opt 4 but CircularShift indicate the position of the last element
  (e.g. with ":": "Ex:An example"
		r3=> {"Ex:", "An ", "example "} + delimiter length {0, 1, 1}
		r4=> {("Ex:An example ", 2), ("An example Ex:", 0), ("example Ex:An ", 1)}
		       ^ shift           ^ index last word
		r5=> {"Ex:An example"      ,  "An example Ex:",      "example Ex:An"}
  )
  pro: similar to opt 4
       allow more output than input
  con: change the type of the result of the shifter
	   overkill

IMHO: Option 3 can be implemented easily and quickly
               and the left over should be fine
      Option 4 is doable too but more complexe + new class
